"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mqtt_constants_1 = require("./mqtt.constants");
const packet_stream_1 = require("./packet-stream");
const errors_1 = require("./errors");
const packets_1 = require("./packets");
const mqtt_utilities_1 = require("./mqtt.utilities");
class MqttParser {
    constructor(errorCallback, debug) {
        this.debug = debug;
        this.lock = mqtt_utilities_1.createLock();
        this.mapping = [
            [mqtt_constants_1.PacketTypes.TYPE_CONNACK, () => new packets_1.ConnectResponsePacket()],
            [mqtt_constants_1.PacketTypes.TYPE_PUBLISH, () => new packets_1.PublishRequestPacket()],
            [mqtt_constants_1.PacketTypes.TYPE_PUBACK, () => new packets_1.PublishAckPacket()],
            [mqtt_constants_1.PacketTypes.TYPE_PUBREC, () => new packets_1.PublishReceivedPacket()],
            [mqtt_constants_1.PacketTypes.TYPE_PUBREL, () => new packets_1.PublishReleasePacket()],
            [mqtt_constants_1.PacketTypes.TYPE_PUBCOMP, () => new packets_1.PublishCompletePacket()],
            [mqtt_constants_1.PacketTypes.TYPE_SUBSCRIBE, () => new packets_1.SubscribeRequestPacket()],
            [mqtt_constants_1.PacketTypes.TYPE_SUBACK, () => new packets_1.SubscribeResponsePacket()],
            [mqtt_constants_1.PacketTypes.TYPE_UNSUBSCRIBE, () => new packets_1.UnsubscribeRequestPacket()],
            [mqtt_constants_1.PacketTypes.TYPE_UNSUBACK, () => new packets_1.UnsubscribeResponsePacket()],
            [mqtt_constants_1.PacketTypes.TYPE_PINGREQ, () => new packets_1.PingRequestPacket()],
            [mqtt_constants_1.PacketTypes.TYPE_PINGRESP, () => new packets_1.PingResponsePacket()],
            [mqtt_constants_1.PacketTypes.TYPE_DISCONNECT, () => new packets_1.DisconnectRequestPacket()],
        ];
        this.stream = packet_stream_1.PacketStream.empty();
        /* eslint @typescript-eslint/no-empty-function: "off" */
        this.errorCallback = (errorCallback !== null && errorCallback !== void 0 ? errorCallback : (() => { }));
    }
    reset() {
        this.stream = packet_stream_1.PacketStream.empty();
        this.lock.locked = false;
        this.lock.resolver = null;
    }
    async parse(data) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        await this.lock.wait();
        this.lock.lock();
        let startPos = this.stream.position;
        this.stream.write(data);
        this.stream.position = startPos;
        const results = [];
        try {
            while (this.stream.remainingBytes > 0) {
                const type = this.stream.readByte() >> 4;
                let packet;
                try {
                    // @ts-ignore - if undefined -> catched
                    packet = this.mapping.find(x => x[0] === type)[1]();
                }
                catch (e) {
                    (_b = (_a = this).debug) === null || _b === void 0 ? void 0 : _b.call(_a, `No packet found for ${type};
                         @${this.stream.position}/${this.stream.length}
                         parsed: ${results.length}`);
                    continue;
                }
                this.stream.seek(-1);
                let exitParser = false;
                try {
                    packet.read(this.stream);
                    results.push(packet);
                    this.stream.cut();
                    startPos = this.stream.position;
                }
                catch (e) {
                    if (e instanceof errors_1.EndOfStreamError) {
                        (_d = (_c = this).debug) === null || _d === void 0 ? void 0 : _d.call(_c, `EOS:\n  ${packet.remainingPacketLength} got: ${this.stream.length} (+) ${data.byteLength};\n  return: ${startPos};`);
                        this.stream.position = startPos;
                        exitParser = true;
                    }
                    else {
                        (_f = (_e = this).debug) === null || _f === void 0 ? void 0 : _f.call(_e, `Error in parser (type: ${type}): 
                        ${e.stack}; 
                        exiting; 
                        resetting;
                        stream: ${this.stream.data.toString('base64')}`);
                        this.errorCallback(e);
                        exitParser = true;
                        this.stream = packet_stream_1.PacketStream.empty();
                    }
                }
                if (exitParser)
                    break;
            }
        }
        catch (e) {
            (_h = (_g = this).debug) === null || _h === void 0 ? void 0 : _h.call(_g, `Error in parser: 
                ${e.stack};
                 resetting; 
                 stream: ${this.stream.data.toString('base64')}`);
            this.stream = packet_stream_1.PacketStream.empty();
            this.errorCallback(e);
        }
        this.lock.unlock();
        return results;
    }
}
exports.MqttParser = MqttParser;
//# sourceMappingURL=mqtt.parser.js.map