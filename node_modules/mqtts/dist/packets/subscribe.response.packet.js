"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mqtt_constants_1 = require("../mqtt.constants");
const mqtt_packet_1 = require("../mqtt.packet");
const errors_1 = require("../errors");
class SubscribeResponsePacket extends mqtt_packet_1.MqttPacket {
    constructor() {
        super(mqtt_constants_1.PacketTypes.TYPE_SUBACK);
    }
    get returnCodes() {
        return this._returnCodes;
    }
    set returnCodes(value) {
        value.forEach(e => this.assertValidReturnCode(e));
        this._returnCodes = value;
    }
    get hasIdentifier() {
        return true;
    }
    read(stream) {
        super.read(stream);
        const returnCodeLen = this.remainingPacketLength - 2;
        this._returnCodes = [];
        for (let i = 0; i < returnCodeLen; i++) {
            const code = stream.readByte();
            this.assertValidReturnCode(code);
            this._returnCodes.push(code);
        }
    }
    write() {
        throw new errors_1.InvalidDirectionError('write');
    }
    isError(returnCode) {
        return returnCode === 128;
    }
    getReturnCodeName(returnCode) {
        // @ts-ignore - this is valid
        return SubscribeResponsePacket.qosLevels[`q${returnCode.toString()}`];
    }
    assertValidReturnCode(returnCode) {
        if (returnCode & 124) {
            throw new Error(`Invalid return code: ${returnCode}`);
        }
    }
}
exports.SubscribeResponsePacket = SubscribeResponsePacket;
SubscribeResponsePacket.qosLevels = {
    q0: 'Max QoS 0',
    q1: 'Max QoS 1',
    q2: 'Max QoS 2',
    q128: 'Failure',
};
//# sourceMappingURL=subscribe.response.packet.js.map