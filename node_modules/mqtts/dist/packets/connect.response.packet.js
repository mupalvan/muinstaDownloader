"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mqtt_packet_1 = require("../mqtt.packet");
const mqtt_constants_1 = require("../mqtt.constants");
const errors_1 = require("../errors");
class ConnectResponsePacket extends mqtt_packet_1.MqttPacket {
    constructor() {
        super(mqtt_constants_1.PacketTypes.TYPE_CONNACK);
    }
    get payload() {
        return this._payload;
    }
    get returnCode() {
        return this._returnCode;
    }
    get flags() {
        return this._flags;
    }
    get isSuccess() {
        return this.returnCode === 0;
    }
    get isError() {
        return this.returnCode > 0;
    }
    get errorName() {
        return ConnectResponsePacket.returnCodes[Math.min(this.returnCode, ConnectResponsePacket.returnCodes.length - 1)];
    }
    read(stream) {
        super.read(stream);
        this._flags = stream.readByte();
        this._returnCode = stream.readByte();
        /**
         *  NOT IN MQTT 3.1.1!
         */
        if (this.remainingPacketLength - 2 > 0) {
            this._payload = stream.readStringAsBuffer();
        }
    }
    write() {
        throw new errors_1.InvalidDirectionError('write');
    }
}
exports.ConnectResponsePacket = ConnectResponsePacket;
ConnectResponsePacket.returnCodes = [
    'Connection accepted',
    'Unacceptable protocol version',
    'Identifier rejected',
    'Server unavailable',
    'Bad user name or password',
    'Not authorized',
];
//# sourceMappingURL=connect.response.packet.js.map