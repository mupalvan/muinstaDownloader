"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mqtt_constants_1 = require("../mqtt.constants");
const packet_stream_1 = require("../packet-stream");
const mqtt_packet_1 = require("../mqtt.packet");
const errors_1 = require("../errors");
class PublishRequestPacket extends mqtt_packet_1.MqttPacket {
    constructor(topic, payload, qos) {
        super(mqtt_constants_1.PacketTypes.TYPE_PUBLISH);
        this._topic = (topic !== null && topic !== void 0 ? topic : '');
        this._payload = payload ? (payload instanceof Buffer ? payload : Buffer.from(payload)) : Buffer.from([]);
        this.qosLevel = (qos !== null && qos !== void 0 ? qos : 0);
    }
    get payload() {
        return this._payload;
    }
    get topic() {
        return this._topic;
    }
    set topic(value) {
        this.assertValidString(value);
        this._topic = value;
    }
    get duplicate() {
        return (this.packetFlags & 8) === 8;
    }
    set duplicate(val) {
        if (val) {
            this.packetFlags |= 8;
        }
        else {
            this.packetFlags &= ~8;
        }
    }
    get retained() {
        return (this.packetFlags & 1) === 1;
    }
    set retained(val) {
        if (val) {
            this.packetFlags |= 1;
        }
        else {
            this.packetFlags &= ~1;
        }
    }
    get qosLevel() {
        return (this.packetFlags & 6) >> 1;
    }
    set qosLevel(val) {
        this.assertValidQosLevel(val);
        this.packetFlags |= (val & 3) << 1;
    }
    get hasIdentifier() {
        return !!this.qosLevel;
    }
    get inlineIdentifier() {
        return true;
    }
    read(stream) {
        super.read(stream);
        const lastPos = stream.position;
        this._topic = stream.readString();
        this.readIdentifier(stream);
        const payloadLength = this.remainingPacketLength - (stream.position - lastPos);
        if (payloadLength === 0)
            return;
        if (payloadLength > stream.length - stream.position)
            throw new errors_1.EndOfStreamError();
        this._payload = stream.read(payloadLength);
    }
    write(stream) {
        const data = this.writeIdentifier(packet_stream_1.PacketStream.empty().writeString(this._topic)).write(this._payload);
        this.remainingPacketLength = data.length;
        super.write(stream);
        stream.write(data.data);
    }
}
exports.PublishRequestPacket = PublishRequestPacket;
//# sourceMappingURL=publish.request.packet.js.map