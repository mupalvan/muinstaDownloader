"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mqtt_packet_1 = require("../mqtt.packet");
const mqtt_constants_1 = require("../mqtt.constants");
const packet_stream_1 = require("../packet-stream");
const lodash_1 = require("lodash");
const errors_1 = require("../errors");
class ConnectRequestPacket extends mqtt_packet_1.MqttPacket {
    constructor(options) {
        super(mqtt_constants_1.PacketTypes.TYPE_CONNECT);
        this.options = lodash_1.defaults(options, {
            protocolLevel: 4,
            protocolName: 'MQTT',
            flags: ConnectRequestPacket.makeFlags(options),
            clientId: 'mqtts_' + lodash_1.random(0, 200000),
            keepAlive: 60,
        });
    }
    static makeFlags(options) {
        var _a;
        if (!options)
            return 0;
        let flags = 0;
        if (options.username)
            flags |= 0x1 << 7;
        if (options.password)
            flags |= 0x1 << 6;
        if (options.will) {
            if (options.will.retained)
                flags |= 0x1 << 5;
            flags |= ((_a = options.will.qosLevel, (_a !== null && _a !== void 0 ? _a : 0)) & 0x03) << 3;
            flags |= 0x1 << 2;
        }
        if (options.clean)
            flags |= 0x1 << 1;
        return flags;
    }
    write(stream) {
        const { protocolLevel, protocolName, flags, clientId, keepAlive, will, username, password } = this.options;
        const data = packet_stream_1.PacketStream.empty()
            .writeString((protocolName !== null && protocolName !== void 0 ? protocolName : 'MQTT'))
            .writeByte((protocolLevel !== null && protocolLevel !== void 0 ? protocolLevel : 4))
            .writeByte((flags !== null && flags !== void 0 ? flags : ConnectRequestPacket.makeFlags(this.options)))
            .writeWord((keepAlive !== null && keepAlive !== void 0 ? keepAlive : 60))
            .writeString((clientId !== null && clientId !== void 0 ? clientId : 'mqtt_' + lodash_1.random(0, 200000)));
        if (will)
            data.writeString(will.topic).writeString(will.payload.toString());
        if (username)
            data.writeString(username);
        if (password)
            data.writeString(password);
        this.remainingPacketLength = data.length;
        super.write(stream);
        stream.write(data.data);
    }
    read() {
        throw new errors_1.InvalidDirectionError('read');
    }
}
exports.ConnectRequestPacket = ConnectRequestPacket;
//# sourceMappingURL=connect.request.packet.js.map