"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const packet_stream_1 = require("./packet-stream");
const mqtt_utilities_1 = require("./mqtt.utilities");
class MqttPacket {
    constructor(packetType) {
        this.packetFlags = 0;
        this.remainingPacketLength = 0;
        this._packetType = packetType;
    }
    get packetType() {
        return this._packetType;
    }
    set identifier(value) {
        if (this.hasIdentifier) {
            this._identifier = Math.max(Math.min((value !== null && value !== void 0 ? value : 0), 0xffff), 0);
        }
    }
    get identifier() {
        return this.hasIdentifier ? this._identifier : null;
    }
    get hasIdentifier() {
        return false;
    }
    get inlineIdentifier() {
        return false;
    }
    generateIdentifier() {
        if (mqtt_utilities_1.nullOrUndefined(this._identifier)) {
            this._identifier = MqttPacket.generateIdentifier();
        }
        return this._identifier;
    }
    static generateIdentifier() {
        MqttPacket.nextId++;
        MqttPacket.nextId &= 0xffff;
        return MqttPacket.nextId;
    }
    read(stream) {
        const typeAndFlags = stream.readByte();
        const type = (typeAndFlags & 0xf0) >> 4;
        const flags = typeAndFlags & 0x0f;
        if (type !== this._packetType) {
            throw new Error('Invalid packet type');
        }
        this.packetFlags = flags;
        this.readRemainingLength(stream);
        if (this.hasIdentifier && !this.inlineIdentifier) {
            this.readIdentifier(stream);
        }
    }
    readIdentifier(stream) {
        if (this.hasIdentifier)
            this._identifier = stream.readWord();
        return stream;
    }
    write(stream) {
        stream.writeByte(((this._packetType & 0x0f) << 4) | (this.packetFlags & 0x0f));
        if (this.hasIdentifier && !this.inlineIdentifier)
            this.remainingPacketLength += 2;
        this.writeRemainingLength(stream);
        if (this.hasIdentifier && !this.inlineIdentifier)
            this.writeIdentifier(stream);
    }
    writeIdentifier(stream) {
        var _a;
        if (this.hasIdentifier)
            stream.writeWord((_a = this._identifier, (_a !== null && _a !== void 0 ? _a : this.generateIdentifier())));
        return stream;
    }
    readRemainingLength(stream) {
        this.remainingPacketLength = 0;
        let multiplier = 1;
        let encodedByte;
        do {
            encodedByte = stream.readByte();
            this.remainingPacketLength += (encodedByte & 0x7f) * multiplier;
            if (multiplier > 128 * 128 * 128) {
                throw new Error(`Invalid length @${stream.position}/${stream.length}; currentLength: ${this.remainingPacketLength}`);
            }
            multiplier *= 0x80;
        } while ((encodedByte & 0x80) !== 0);
    }
    writeRemainingLength(stream) {
        let num = this.remainingPacketLength;
        let digit = 0;
        do {
            digit = num % 128 | 0;
            num = (num / 128) | 0;
            if (num > 0)
                digit = digit | 0x80;
            stream.writeByte(digit);
        } while (num > 0);
    }
    assertValidStringLength(str) {
        if (str.length > 0xffff) {
            throw new Error(`The string ${str.substring(0, 20)} is longer than 0xffff bytes.`);
        }
    }
    assertValidString(str) {
        this.assertValidStringLength(str);
        /* eslint no-control-regex: "off" */
        if (str.match(/[\xD8-\xDF][\x00-\xFF]|\x00\x00/) !== null) {
            throw new Error(`The string ${str.substring(0, 20)} contains invalid characters`);
        }
    }
    assertValidQosLevel(level) {
        if (level < 0 || level > 2) {
            throw new Error(`Invalid QoS level ${level}.`);
        }
    }
    toString() {
        const stream = packet_stream_1.PacketStream.empty();
        return stream.data.toString('utf8');
    }
}
exports.MqttPacket = MqttPacket;
MqttPacket.nextId = 0;
//# sourceMappingURL=mqtt.packet.js.map