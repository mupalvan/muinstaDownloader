"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mqtt_constants_1 = require("./mqtt.constants");
function topicListener(options) {
    return {
        eventName: 'message',
        validator: data => {
            if (data.topic === options.topic) {
                return options.validator ? options.validator(data) : true;
            }
            return false;
        },
        transformer: options.transformer,
        onData: options.onData,
    };
}
exports.topicListener = topicListener;
function matchTopic(baseTopic, incomingTopic) {
    if (baseTopic.length === incomingTopic.length && baseTopic === incomingTopic)
        return true;
    const parts = baseTopic.split('+');
    let remaining = incomingTopic;
    for (const part of parts) {
        if (!remaining.startsWith(part)) {
            return false;
        }
        remaining = removeUntil(remaining.substring(part.length), '/');
    }
    return true;
}
exports.matchTopic = matchTopic;
function removeUntil(input, char) {
    return input.substring(Math.max(input.indexOf(char), 0));
}
exports.removeUntil = removeUntil;
function extractParams(template, topic) {
    const templateParts = template.split('/');
    const topicParts = topic.split('/');
    const params = {};
    for (let i = 0; i < Math.min(templateParts.length, topicParts.length); i++) {
        if (templateParts[i].startsWith(':')) {
            params[templateParts[i].substring(1)] = topicParts[i];
        }
    }
    return params;
}
exports.extractParams = extractParams;
exports.nullOrUndefined = (input) => input == undefined;
function isPacket(target, type) {
    return target.packetType === type;
}
exports.isPacket = isPacket;
exports.isConnect = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_CONNECT);
exports.isConnAck = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_CONNACK);
exports.isPublish = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_PUBLISH);
exports.isPubAck = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_PUBACK);
exports.isPubRec = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_PUBREC);
exports.isPubRel = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_PUBREL);
exports.isPubComp = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_PUBCOMP);
exports.isSubscribe = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_SUBSCRIBE);
exports.isSubAck = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_SUBACK);
exports.isUnsubscribe = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_UNSUBSCRIBE);
exports.isUnsubAck = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_UNSUBACK);
exports.isPingReq = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_PINGREQ);
exports.isPingResp = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_PINGRESP);
exports.isDisconnect = (target) => isPacket(target, mqtt_constants_1.PacketTypes.TYPE_DISCONNECT);
/**
 * Some workaround for async requests:
 * This prevents the execution if there's already something in the buffer.
 * Note: if something fails, this will lock forever
 * @type {{unlock: () => void; resolve: null; lock: () => void; locked: boolean}}
 */
function createLock() {
    return {
        locked: false,
        lock() {
            this.locked = true;
        },
        unlock() {
            this.locked = false;
            if (this.resolver) {
                this.resolver();
                this.resolver = null;
            }
        },
        resolver: null,
        wait() {
            if (this.locked) {
                return new Promise(resolve => {
                    this.resolver = resolve;
                });
            }
            else {
                return Promise.resolve();
            }
        },
    };
}
exports.createLock = createLock;
async function resolve(resolvable) {
    return typeof resolvable === 'object' ? resolvable : await resolvable();
}
exports.resolve = resolve;
//# sourceMappingURL=mqtt.utilities.js.map