import { ListenerInfo, Resolvable } from './mqtt.types';
import { MqttMessage } from './mqtt.message';
import { MqttPacket } from './mqtt.packet';
import { ConnectRequestPacket, ConnectResponsePacket, DisconnectRequestPacket, PingRequestPacket, PingResponsePacket, PublishAckPacket, PublishCompletePacket, PublishReceivedPacket, PublishReleasePacket, PublishRequestPacket, SubscribeRequestPacket, SubscribeResponsePacket, UnsubscribeRequestPacket, UnsubscribeResponsePacket } from './packets';
export declare function topicListener<T>(options: {
    topic: string;
    transformer: (data: MqttMessage) => T | PromiseLike<T>;
    validator?: (data: MqttMessage) => boolean | PromiseLike<boolean>;
    onData: (data: T) => void | PromiseLike<void>;
}): ListenerInfo<MqttMessage, T>;
export declare function matchTopic(baseTopic: string, incomingTopic: string): boolean;
export declare function removeUntil(input: string, char: string): string;
export declare function extractParams(template: string, topic: string): object;
export interface Resolvers<T> {
    resolve: (value: T) => void;
    reject: (error: Error) => void;
}
export declare const nullOrUndefined: (input: any) => boolean;
export declare function isPacket(target: any, type: number): boolean;
export declare const isConnect: (target: MqttPacket) => target is ConnectRequestPacket;
export declare const isConnAck: (target: MqttPacket) => target is ConnectResponsePacket;
export declare const isPublish: (target: MqttPacket) => target is PublishRequestPacket;
export declare const isPubAck: (target: MqttPacket) => target is PublishAckPacket;
export declare const isPubRec: (target: MqttPacket) => target is PublishReceivedPacket;
export declare const isPubRel: (target: MqttPacket) => target is PublishReleasePacket;
export declare const isPubComp: (target: MqttPacket) => target is PublishCompletePacket;
export declare const isSubscribe: (target: MqttPacket) => target is SubscribeRequestPacket;
export declare const isSubAck: (target: MqttPacket) => target is SubscribeResponsePacket;
export declare const isUnsubscribe: (target: MqttPacket) => target is UnsubscribeRequestPacket;
export declare const isUnsubAck: (target: MqttPacket) => target is UnsubscribeResponsePacket;
export declare const isPingReq: (target: MqttPacket) => target is PingRequestPacket;
export declare const isPingResp: (target: MqttPacket) => target is PingResponsePacket;
export declare const isDisconnect: (target: MqttPacket) => target is DisconnectRequestPacket;
/**
 * Some workaround for async requests:
 * This prevents the execution if there's already something in the buffer.
 * Note: if something fails, this will lock forever
 * @type {{unlock: () => void; resolve: null; lock: () => void; locked: boolean}}
 */
export declare function createLock(): Lock;
export declare function resolve<T extends object>(resolvable: Resolvable<T>): Promise<T>;
export interface Lock {
    resolver: Function | null;
    locked: boolean;
    lock: () => void;
    unlock: () => void;
    wait: () => Promise<void>;
}
