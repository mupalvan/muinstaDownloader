/// <reference types="node" />
import { Observable, Subject } from 'rxjs';
import { ExecuteDelayed, ExecuteNextTick, ExecutePeriodically, IncomingListenMessage, ListenOptions, ListenSubscribeOptions, MqttClientConstructorOptions, MqttSubscription, RegisterClientOptions, Resolvable, StopExecuting } from './mqtt.types';
import { PacketFlowData, PacketFlowFunc } from './flow';
import { MqttParser } from './mqtt.parser';
import { Transport } from './transport';
import { MqttPacket } from './mqtt.packet';
import { ConnectResponsePacket } from './packets';
import { MqttMessage, MqttMessageOutgoing } from './mqtt.message';
export declare class MqttClient {
    private mqttDebug;
    private packetDebug;
    private pingDebug;
    protected executeNextTick: ExecuteNextTick;
    protected executePeriodically: ExecutePeriodically;
    protected stopExecuting: StopExecuting;
    protected executeDelayed: ExecuteDelayed;
    /**
     * An error has been encountered, the client will no longer work correctly
     * @type {Subject<Error>}
     */
    $error: Subject<Error>;
    /**
     * An error has been encountered, the client might still continue to work
     * @type {Subject<Error>}
     */
    $warning: Subject<Error>;
    /**
     *
     * @type {Subject<void>}
     */
    $open: Subject<void>;
    /**
     * The client successfully established a connection
     * @type {Subject<void>}
     */
    $connect: Subject<ConnectResponsePacket>;
    /**
     * The client disconnected.
     * @type {Subject<void>}
     */
    $disconnect: Subject<string | undefined>;
    $message: Subject<MqttMessage>;
    get keepAlive(): number;
    set keepAlive(value: number);
    protected transport: Transport<unknown>;
    protected parser: MqttParser;
    protected connectTimer?: object;
    protected keepAliveTimer?: object;
    protected autoReconnect: boolean;
    protected state: MqttClientState;
    protected activeFlows: PacketFlowData<any>[];
    constructor(options: MqttClientConstructorOptions);
    connect(options?: Resolvable<RegisterClientOptions>): Promise<any>;
    protected getConnectOptions(): Promise<RegisterClientOptions>;
    protected registerClient(options: RegisterClientOptions, noNewPromise?: boolean): Promise<any>;
    protected getConnectFlow(options: any): PacketFlowFunc<any>;
    publish(message: MqttMessageOutgoing): Promise<MqttMessageOutgoing>;
    subscribe(subscription: MqttSubscription): Promise<MqttSubscription>;
    unsubscribe(subscription: MqttSubscription): Promise<void>;
    disconnect(): Promise<void>;
    listenSubscribe<T = IncomingListenMessage<any>>(topic: string): Promise<Observable<T>>;
    listenSubscribe<T = IncomingListenMessage<any>>(options: ListenSubscribeOptions<T>): Promise<Observable<T>>;
    listen<T>(topic: string): Observable<T>;
    listen<T>(options: ListenOptions<T>): Observable<T>;
    startFlow<T>(flow: PacketFlowFunc<T>): Promise<T>;
    /**
     *
     * @param {MqttPacket} packet
     * @returns {boolean} true if a flow has been found
     */
    protected continueFlows(packet: MqttPacket): boolean;
    protected checkFlows(): void;
    protected updateKeepAlive(value: number): void;
    protected sendPacket(packet: MqttPacket): void;
    protected parseData(data: Buffer): Promise<void>;
    protected handlePacket(packet: MqttPacket): Promise<void>;
    protected logPacket(packet: MqttPacket, action: string): void;
    protected reset(): void;
    protected setConnecting(): void;
    protected setConnected(): void;
    protected setDisconnected(reason?: string): void;
}
export interface MqttClientState {
    connected: boolean;
    connecting: boolean;
    disconnected: boolean;
    connectOptions?: RegisterClientOptions;
    connectOptionsResolver?: Resolvable<RegisterClientOptions>;
    startResolve?: () => void;
    startReject?: (e: any) => void;
}
