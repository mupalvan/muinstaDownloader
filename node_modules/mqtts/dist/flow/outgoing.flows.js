"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const packets_1 = require("../packets");
const lodash_1 = require("lodash");
const mqtt_packet_1 = require("../mqtt.packet");
const mqtt_utilities_1 = require("../mqtt.utilities");
function outgoingConnectFlow(options) {
    options = lodash_1.defaults(options, {
        protocol: 3,
        clientId: 'mqtt_' + lodash_1.random(1, 100000),
        cleanSession: true,
        keepAlive: 60,
    });
    return (success, error) => ({
        start: () => new packets_1.ConnectRequestPacket(options),
        accept: mqtt_utilities_1.isConnAck,
        next: (res) => (res.isSuccess ? success(options) : error(res.errorName)),
    });
}
exports.outgoingConnectFlow = outgoingConnectFlow;
function outgoingDisconnectFlow() {
    return success => ({
        start: () => {
            success();
            return new packets_1.DisconnectRequestPacket();
        },
    });
}
exports.outgoingDisconnectFlow = outgoingDisconnectFlow;
function outgoingPingFlow() {
    return success => ({
        start: () => new packets_1.PingRequestPacket(),
        accept: mqtt_utilities_1.isPingResp,
        next: () => success(),
    });
}
exports.outgoingPingFlow = outgoingPingFlow;
function outgoingPublishFlow(message, _identifier) {
    const id = (_identifier !== null && _identifier !== void 0 ? _identifier : mqtt_packet_1.MqttPacket.generateIdentifier());
    let receivedPubRec = false;
    return success => ({
        start: () => {
            const packet = new packets_1.PublishRequestPacket(message.topic, message.payload);
            packet.qosLevel = message.qosLevel || 0;
            packet.duplicate = message.duplicate || false;
            packet.retained = message.retained || false;
            if (!message.qosLevel)
                success(message);
            else
                packet.identifier = id;
            return packet;
        },
        accept: (packet) => {
            if (message.qosLevel === 1 && mqtt_utilities_1.isPubAck(packet)) {
                return packet.identifier === id;
            }
            else if (message.qosLevel === 2) {
                if (mqtt_utilities_1.isPubRec(packet)) {
                    return packet.identifier === id;
                }
                else if (receivedPubRec && mqtt_utilities_1.isPubComp(packet)) {
                    return packet.identifier === id;
                }
            }
            return false;
        },
        next: (packet) => {
            if (mqtt_utilities_1.isPubAck(packet) || mqtt_utilities_1.isPubComp(packet)) {
                success(message);
            }
            else if (mqtt_utilities_1.isPubRec(packet)) {
                receivedPubRec = true;
                return new packets_1.PublishReleasePacket(id);
            }
        },
    });
}
exports.outgoingPublishFlow = outgoingPublishFlow;
function outgoingSubscribeFlow(subscription, identifier) {
    const id = (identifier !== null && identifier !== void 0 ? identifier : mqtt_packet_1.MqttPacket.generateIdentifier());
    return (success, error) => ({
        start: () => {
            const packet = new packets_1.SubscribeRequestPacket(subscription.topic, subscription.qosLevel || 0);
            packet.identifier = id;
            return packet;
        },
        accept: (packet) => mqtt_utilities_1.isSubAck(packet) && packet.identifier === id,
        next: (packet) => {
            if (packet.returnCodes.every(value => !packet.isError(value))) {
                success(subscription);
            }
            else {
                error(`Failed to subscribe to ${subscription.topic}`);
            }
        },
    });
}
exports.outgoingSubscribeFlow = outgoingSubscribeFlow;
function outgoingUnsubscribeFlow(subscription, identifier) {
    const id = (identifier !== null && identifier !== void 0 ? identifier : mqtt_packet_1.MqttPacket.generateIdentifier());
    return success => ({
        start: () => {
            const packet = new packets_1.UnsubscribeRequestPacket(subscription.topic);
            packet.identifier = id;
            return packet;
        },
        accept: (packet) => mqtt_utilities_1.isUnsubAck(packet) && packet.identifier === id,
        next: () => success(),
    });
}
exports.outgoingUnsubscribeFlow = outgoingUnsubscribeFlow;
//# sourceMappingURL=outgoing.flows.js.map