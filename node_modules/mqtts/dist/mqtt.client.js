"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const flow_1 = require("./flow");
const mqtt_parser_1 = require("./mqtt.parser");
const transport_1 = require("./transport");
const lodash_1 = require("lodash");
const packet_stream_1 = require("./packet-stream");
const mqtt_constants_1 = require("./mqtt.constants");
const operators_1 = require("rxjs/operators");
const debug = require("debug");
const mqtt_utilities_1 = require("./mqtt.utilities");
const errors_1 = require("./errors");
class MqttClient {
    constructor(options) {
        var _a, _b, _c;
        this.mqttDebug = debug('mqtt:client');
        this.packetDebug = this.mqttDebug.extend('packet');
        this.pingDebug = this.mqttDebug.extend('ping');
        /**
         * An error has been encountered, the client will no longer work correctly
         * @type {Subject<Error>}
         */
        this.$error = new rxjs_1.Subject();
        /**
         * An error has been encountered, the client might still continue to work
         * @type {Subject<Error>}
         */
        this.$warning = new rxjs_1.Subject();
        /**
         *
         * @type {Subject<void>}
         */
        this.$open = new rxjs_1.Subject();
        /**
         * The client successfully established a connection
         * @type {Subject<void>}
         */
        this.$connect = new rxjs_1.Subject();
        /**
         * The client disconnected.
         * @type {Subject<void>}
         */
        this.$disconnect = new rxjs_1.Subject();
        this.$message = new rxjs_1.Subject();
        this.activeFlows = [];
        this.state = {
            connected: false,
            connecting: false,
            disconnected: false,
        };
        this.autoReconnect = !!options.autoReconnect;
        this.parser = (_a = options.parser, (_a !== null && _a !== void 0 ? _a : new mqtt_parser_1.MqttParser(e => this.$error.next(e), this.mqttDebug.extend('parser'))));
        this.transport = (_b = options.transport, (_b !== null && _b !== void 0 ? _b : new transport_1.TlsTransport({
            url: options.url,
            enableTrace: (_c = options.enableTrace, (_c !== null && _c !== void 0 ? _c : false)),
            proxyOptions: options.proxyOptions,
        })));
        try {
            this.executeNextTick = process.nextTick;
            this.executePeriodically = (ms, cb) => setInterval(cb, ms);
            this.executeDelayed = (ms, cb) => setTimeout(cb, ms);
            this.stopExecuting = clearInterval;
        }
        catch (e) {
            this.mqttDebug(`Could not register timers: ${e.stack}`);
        }
    }
    get keepAlive() {
        var _a, _b, _c;
        return _c = (_b = (_a = this.state) === null || _a === void 0 ? void 0 : _a.connectOptions) === null || _b === void 0 ? void 0 : _b.keepAlive, (_c !== null && _c !== void 0 ? _c : 0);
    }
    set keepAlive(value) {
        var _a;
        if ((_a = this.state) === null || _a === void 0 ? void 0 : _a.connectOptions) {
            this.state.connectOptions.keepAlive = value;
            if (value) {
                this.updateKeepAlive(value);
            }
        }
    }
    connect(options) {
        var _a;
        if (this.state.connected || this.state.connecting) {
            throw new Error('Invalid State: The client is already connecting/connected!');
        }
        this.mqttDebug('Connecting...');
        this.state.connectOptionsResolver = (_a = this.state.connectOptionsResolver, (_a !== null && _a !== void 0 ? _a : options));
        this.setConnecting();
        return new Promise(resolve => {
            this.transport.callbacks = {
                disconnect: (data) => {
                    var _a, _b;
                    if (data) {
                        this.mqttDebug(`Transport disconnected with ${data}\n${data.stack}`);
                        this.$error.next(data);
                    }
                    this.setDisconnected(`error in transport ${(_a = data) === null || _a === void 0 ? void 0 : _a.name} ${(_b = data) === null || _b === void 0 ? void 0 : _b.stack}`);
                },
                connect: () => {
                    this.$open.next();
                    resolve();
                },
                error: (e) => this.$error.next(e),
                data: (data) => this.parseData(data),
            };
            this.transport.connect();
        }).then(async () => this.registerClient(await this.getConnectOptions()));
    }
    async getConnectOptions() {
        var _a;
        return (this.state.connectOptions = lodash_1.defaults(await mqtt_utilities_1.resolve(this.state.connectOptionsResolver || {}), (_a = this.state.connectOptions, (_a !== null && _a !== void 0 ? _a : {}))));
    }
    registerClient(options, noNewPromise = false) {
        var _a;
        let promise;
        if (noNewPromise) {
            promise = this.startFlow(this.getConnectFlow(options));
        }
        else {
            promise = new Promise((resolve, reject) => {
                this.state.startResolve = resolve;
                this.state.startReject = reject;
            });
            this.startFlow(this.getConnectFlow(options))
                .then(() => { var _a, _b; return (_b = (_a = this.state).startResolve) === null || _b === void 0 ? void 0 : _b.call(_a); })
                .catch(e => { var _a, _b; return (_b = (_a = this.state).startReject) === null || _b === void 0 ? void 0 : _b.call(_a, e); });
        }
        this.connectTimer =
            options.connectDelay === null
                ? undefined
                : this.executeDelayed((_a = options.connectDelay, (_a !== null && _a !== void 0 ? _a : 2000)), () => this.registerClient(options, true)
                    .then(() => { var _a, _b; return (_b = (_a = this.state).startResolve) === null || _b === void 0 ? void 0 : _b.call(_a); })
                    .catch(e => { var _a, _b; return (_b = (_a = this.state).startReject) === null || _b === void 0 ? void 0 : _b.call(_a, e); }));
        return promise;
    }
    getConnectFlow(options) {
        return flow_1.outgoingConnectFlow(options);
    }
    publish(message) {
        return this.startFlow(flow_1.outgoingPublishFlow(message));
    }
    subscribe(subscription) {
        return this.startFlow(flow_1.outgoingSubscribeFlow(subscription));
    }
    unsubscribe(subscription) {
        return this.startFlow(flow_1.outgoingUnsubscribeFlow(subscription));
    }
    disconnect() {
        this.autoReconnect = false;
        return this.startFlow(flow_1.outgoingDisconnectFlow());
    }
    listenSubscribe(options) {
        const listener = typeof options === 'string' ? { topic: options } : options;
        return this.subscribe({
            ...listener.subscriptionInfo,
            topic: listener.topic.replace(/\/:[A-Za-z-_0-9]+/g, '/+'),
        }).then(() => this.listen(listener));
    }
    listen(options) {
        const listener = typeof options === 'string' ? { topic: options } : options;
        const paramRegex = /\/:[A-Za-z-_0-9]+/g;
        let baseTopic = listener.topic;
        if (listener.topic.match(paramRegex)) {
            baseTopic = listener.topic.replace(paramRegex, '/+');
        }
        return this.$message.pipe(operators_1.filter(v => {
            if (!mqtt_utilities_1.matchTopic(baseTopic, v.topic))
                return false;
            if (listener.validator === null)
                return true;
            if (!listener.validator) {
                return !!v.payload;
            }
            return listener.validator(v);
        }), operators_1.map((v) => {
            v.params = mqtt_utilities_1.extractParams(listener.topic, v.topic);
            return listener.transformer ? listener.transformer(v) : v;
        }));
    }
    startFlow(flow) {
        return new Promise((resolve, reject) => {
            const data = {
                resolvers: { resolve, reject },
                finished: false,
                callbacks: flow(value => {
                    data.finished = true;
                    resolve(value);
                }, err => {
                    data.finished = true;
                    reject(err);
                }),
            };
            const first = data.callbacks.start();
            if (first)
                this.sendPacket(first);
            if (!data.finished) {
                this.activeFlows.push(data);
            }
        });
    }
    /**
     *
     * @param {MqttPacket} packet
     * @returns {boolean} true if a flow has been found
     */
    continueFlows(packet) {
        var _a, _b, _c, _d;
        let result = false;
        for (const flow of this.activeFlows) {
            if ((_b = (_a = flow.callbacks).accept) === null || _b === void 0 ? void 0 : _b.call(_a, packet)) {
                const next = (_d = (_c = flow.callbacks).next) === null || _d === void 0 ? void 0 : _d.call(_c, packet);
                if (next) {
                    this.sendPacket(next);
                }
                result = true;
            }
        }
        this.checkFlows();
        return result;
    }
    checkFlows() {
        this.activeFlows = lodash_1.pull(this.activeFlows, ...this.activeFlows.filter(f => f.finished));
    }
    updateKeepAlive(value) {
        value = Math.max(value - 0.5, 1);
        if (this.keepAliveTimer) {
            this.stopExecuting(this.keepAliveTimer);
        }
        this.mqttDebug(`Starting keep-alive-ping {delay: ${value}}`);
        this.keepAliveTimer = this.executePeriodically(value * 1000, () => {
            this.startFlow(flow_1.outgoingPingFlow())
                .then(() => this.pingDebug(`PingPong @ ${Date.now()}`))
                .catch(() => this.pingDebug('PingPong failed.'));
        });
    }
    sendPacket(packet) {
        const stream = packet_stream_1.PacketStream.empty();
        packet.write(stream);
        this.logPacket(packet, 'Sent');
        this.transport.send(stream.data);
    }
    async parseData(data) {
        try {
            const results = await this.parser.parse(data);
            if (results.length > 0) {
                results.forEach(r => this.handlePacket(r));
            }
        }
        catch (e) {
            this.$warning.next(e);
        }
    }
    async handlePacket(packet) {
        var _a, _b, _c;
        this.logPacket(packet, 'Received');
        let forceCheckFlows = false;
        switch (packet.packetType) {
            case mqtt_constants_1.PacketTypes.TYPE_CONNACK: {
                const connack = packet;
                if (connack.isSuccess) {
                    this.setConnected();
                    this.$connect.next(connack);
                    if ((_b = (_a = this.state) === null || _a === void 0 ? void 0 : _a.connectOptions) === null || _b === void 0 ? void 0 : _b.keepAlive) {
                        this.updateKeepAlive(this.state.connectOptions.keepAlive);
                    }
                }
                break;
            }
            case mqtt_constants_1.PacketTypes.TYPE_PUBLISH: {
                const pub = packet;
                this.startFlow(flow_1.incomingPublishFlow({
                    topic: pub.topic,
                    payload: pub.payload,
                    qosLevel: pub.qosLevel,
                    retained: pub.retained,
                    duplicate: pub.duplicate,
                }, (_c = pub.identifier, (_c !== null && _c !== void 0 ? _c : undefined))))
                    .then(m => this.$message.next(m))
                    .catch(e => this.$warning.next(e));
                break;
            }
            case mqtt_constants_1.PacketTypes.TYPE_DISCONNECT: {
                // ? this.disconnect();
                this.setDisconnected('disconnect packet received');
                break;
            }
            default:
                forceCheckFlows = true;
        }
        if (!this.continueFlows(packet) && forceCheckFlows) {
            this.$warning.next(new errors_1.UnexpectedPacketError(packet.constructor.name));
        }
    }
    logPacket(packet, action) {
        if (packet.packetType !== mqtt_constants_1.PacketTypes.TYPE_PINGREQ && packet.packetType !== mqtt_constants_1.PacketTypes.TYPE_PINGRESP)
            this.packetDebug(`${action} ${packet.constructor.name}` +
                (packet.identifier ? ` id: ${packet.identifier}` : '') +
                // @ts-ignore - instanceof is too expensive
                (packet.topic ? ` topic: ${packet.topic}` : ''));
    }
    reset() {
        if (this.connectTimer)
            this.stopExecuting(this.connectTimer);
        this.connectTimer = undefined;
        if (this.keepAliveTimer)
            this.stopExecuting(this.keepAliveTimer);
        this.keepAliveTimer = undefined;
        this.activeFlows = [];
        this.state.startResolve = undefined;
        this.state.startReject = undefined;
        this.parser.reset();
    }
    setConnecting() {
        this.state.connecting = true;
        this.state.connected = false;
        this.state.disconnected = false;
    }
    setConnected() {
        this.mqttDebug('Connected!');
        this.state.connecting = false;
        this.state.connected = true;
        this.state.disconnected = false;
        if (this.connectTimer)
            this.stopExecuting(this.connectTimer);
    }
    setDisconnected(reason) {
        const willReconnect = !this.state.disconnected && this.state.connected && !this.state.connecting && this.autoReconnect;
        if (!this.state.disconnected) {
            this.$disconnect.next(reason);
        }
        this.transport.disconnect();
        this.state.connecting = false;
        this.state.connected = false;
        this.state.disconnected = true;
        this.stopExecuting(this.keepAliveTimer);
        this.reset();
        if (willReconnect) {
            this.connect().catch(e => this.$error.next(e));
        }
    }
}
exports.MqttClient = MqttClient;
//# sourceMappingURL=mqtt.client.js.map